<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Registro Plantaciones Forestales BPS ‚Äî Con Titulares (cod_predio)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <style>
    html, body { height:100%; margin:0; font-family: Arial, sans-serif; }
    body { display:flex; }
    #panel { width: 360px; min-width: 300px; max-width: 420px; background: #f7f7f7; display:flex; flex-direction:column; border-right:1px solid #e6e6e6; padding-bottom:8px; box-sizing:border-box; }
    header { background: linear-gradient(90deg,#0b6b2b,#008000); color:white; padding:12px; box-shadow: 0 2px 6px rgba(0,0,0,0.12); }
    header h1 { margin:0; font-size:15px; }
    header p { margin:6px 0 0 0; font-size:12px; opacity:0.95; }

    .toolbar { display:flex; gap:6px; padding:10px; background:#fff; align-items:center; border-bottom:1px solid #e6e6e6; flex-wrap:wrap; }
    .toolbar button, .toolbar select, .toolbar input[type="file"] {
      background:white; border:1px solid #d0d0d0; padding:8px 10px; border-radius:8px;
      cursor:pointer; display:flex; gap:6px; align-items:center; font-size:13px;
    }
    .toolbar button.primary { background:#0b6b2b; color:white; border-color:#0b6b2b; }
    .controls { padding:10px; display:flex; flex-direction:column; gap:8px; }

    .infoBox { background:#fff; padding:8px 10px; border-radius:8px; box-shadow:0 1px 3px rgba(0,0,0,0.06); font-size:13px; text-align:left; }
    .small { font-size:12px; color:#444; }
    #map { flex:1; height:100vh; }

    .legend { display:flex; gap:8px; align-items:center; font-size:12px; margin-top:6px; flex-wrap:wrap; }
    .dot { width:12px; height:12px; border-radius:50%; display:inline-block; border:1px solid rgba(0,0,0,0.1); }
    .label { background: rgba(255,255,255,0.95); padding:4px 6px; border-radius:6px; border:1px solid #ddd; font-size:12px; font-weight:600; }

    /* estilo para etiqueta de titular */
    .etiqueta-predio {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(0,0,0,0.45);
      padding: 2px 6px;
      font-size: 12px;
      font-weight: 600;
      border-radius: 4px;
      white-space: nowrap;
      pointer-events: none;
      box-shadow: 0 1px 2px rgba(0,0,0,0.15);
    }

    #status-msg {
      position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
      background: rgba(11,107,43,0.95); color: white; padding: 8px 16px;
      border-radius: 20px; font-size: 13px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      opacity: 0; transition: opacity 0.35s ease-in-out; z-index: 99999;
    }
    #status-msg.show { opacity: 1; }

    /* tabla */
    #results { padding:10px; overflow:auto; max-height:40vh; }
    table { width:100%; border-collapse:collapse; font-size:13px; }
    th, td { border:1px solid #e6e6e6; padding:6px; text-align:left; }
    th { background:#f0f0f0; font-weight:700; }
  </style>
</head>
<body>

  <div id="panel">
    <header>
      <h1>üå≥ Registro Plantaciones Forestales BPS ‚Äî Victor E. Mendoza A.</h1>
      <p>Especialista en Gesti√≥n del Catastro Forestal - BPS</p>
    </header>

    <div class="toolbar" style="justify-content:flex-start;">
      <button id="btn-gps"><i class="fa-solid fa-location-dot"></i>&nbsp;Activar GPS</button>
      <button id="btn-gps-vertex" class="primary"><i class="fa-solid fa-crosshairs"></i>&nbsp;Agregar v√©rtice GPS</button>
    </div>

    <div class="controls">
      <div class="infoBox">
        <div class="small">Cargar Excel / CSV con coordenadas</div>
        <div style="display:flex;gap:6px;margin-top:8px;">
          <label style="flex:1;">
            <input id="file-input" type="file" accept=".csv,.xlsx" style="display:none"/>
            <button id="btn-upload" style="width:100%;"><i class="fa-solid fa-file-import"></i>&nbsp;Cargar CSV / Excel</button>
          </label>
        </div>

        <div style="display:flex;gap:6px;margin-top:8px;align-items:center;">
          <label class="small">CRS entrada:</label>
          <select id="crs-select" style="flex:1;">
            <option value="4326">EPSG:4326 (Lat/Lon)</option>
            <option value="32717">EPSG:32717 (UTM 17S)</option>
            <option value="32718" selected>EPSG:32718 (UTM 18S)</option>
            <option value="32719">EPSG:32719 (UTM 19S)</option>
          </select>
        </div>

        <div class="legend" style="margin-top:10px;">
          <div><span class="dot" style="background:#2ecc71"></span><small>&nbsp;&lt;5m</small></div>
          <div><span class="dot" style="background:#f1c40f"></span><small>&nbsp;5-7m</small></div>
          <div><span class="dot" style="background:#e74c3c"></span><small>&nbsp;&gt;7m</small></div>
        </div>

        <div style="margin-top:10px;display:flex;gap:6px;">
          <button id="btn-download-input-geo" title="Descargar pol√≠gono de entrada"><i class="fa-solid fa-download"></i>&nbsp;Descargar pol√≠gono</button>
          <button id="btn-clear"><i class="fa-solid fa-trash"></i>&nbsp;Limpiar</button>
        </div>

        <div style="margin-top:8px;" class="small">
          <div id="info-precision">üì° Precisi√≥n: -- m</div>
        </div>
      </div>

      <div class="infoBox" style="display:flex;flex-direction:column;gap:6px;">
        <div class="small"><b>Resultados MIDAGRI (Predio Rural)</b></div>
        <div style="display:flex;gap:6px;">
          <button id="btn-download-midagri-geo" style="flex:1;"><i class="fa-solid fa-map"></i>&nbsp;GeoJSON</button>
          <button id="btn-download-midagri-csv" style="flex:1;"><i class="fa-solid fa-file-csv"></i>&nbsp;CSV</button>
        </div>
        <div style="margin-top:6px;">
          <button id="btn-zoom-intersect" style="width:100%;"><i class="fa-solid fa-search-location"></i>&nbsp;Zoom a intersectados</button>
        </div>
      </div>

      <div id="results" class="infoBox">
        <div class="small"><b>Predios intersectados</b></div>
        <div id="tabla-inter" style="margin-top:8px;">No hay resultados.</div>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <div id="status-msg" role="status" aria-live="polite"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.11/dist/esri-leaflet.js"></script>

  <script>
  // ---------- UTIL UI ----------
  function showStatus(msg, color="#0b6b2b", timeout=2500){
    const el = document.getElementById('status-msg');
    el.style.background = color;
    el.textContent = msg;
    el.classList.add('show');
    clearTimeout(el._t);
    el._t = setTimeout(()=> el.classList.remove('show'), timeout);
  }

  // ---------- PROJS (DEFINICIONES UTM) ----------
  proj4.defs("EPSG:32717","+proj=utm +zone=17 +south +datum=WGS84 +units=m +no_defs");
  proj4.defs("EPSG:32718","+proj=utm +zone=18 +south +datum=WGS84 +units=m +no_defs");
  proj4.defs("EPSG:32719","+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs");

  // ---------- MAP, CAPAS, etc. (sin cambios funcionales) ----------
  const map = L.map('map', { zoomControl:true, maxZoom: 22}).setView([-7.2, -78.5], 8);
  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'¬© OpenStreetMap'}).addTo(map);
  const googleSat = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',{attribution:'¬© Google'});
  L.control.layers({"OSM":osm,"Google Sat√©lite":googleSat}).addTo(map);

  const gpsLayer = new L.FeatureGroup().addTo(map);
  const uploadedLayer = new L.FeatureGroup().addTo(map);
  const drawnItems = new L.FeatureGroup().addTo(map);
  const trackLayer = L.polyline([], { color:'red', weight:3 }).addTo(map);
  const intersectLayer = new L.FeatureGroup().addTo(map);
  const labelLayer = new L.FeatureGroup().addTo(map);

  let gpsMarker=null, accuracyCircle=null, watchId=null;
  let gpsVertices=[], trackCoords=[];
  let activePolygon=null, lastTrackPoint=null;
  const infoPrecision=document.getElementById('info-precision');
  let intersectFeatures = []; 
  let inputPolygonFeature = null; 
  let propietariosMap = {};

  // ---------- Draw control (usa la nueva funci√≥n de etiqueta) ----------
  const drawControl = new L.Control.Draw({
    draw:{ polygon:{allowIntersection:false,showArea:true,shapeOptions:{color:'#0b6b2b'}}, marker:true, polyline:false, rectangle:false, circle:false, circlemarker:false },
    edit:{ featureGroup:drawnItems, edit:true, remove:true }
  });
  map.addControl(drawControl);
  map.on(L.Draw.Event.CREATED,e=>{
    drawnItems.addLayer(e.layer);
    if(e.layer instanceof L.Polygon){ 
      addOrUpdateLabel(e.layer); 
      try { checkIntersection(e.layer.toGeoJSON()); } catch(e){} 
    }
    saveSession();
  });
  map.on(L.Draw.Event.EDITED,e=>{
    e.layers.eachLayer(l=>{ 
      if(l instanceof L.Polygon){ 
        addOrUpdateLabel(l); 
        try { checkIntersection(l.toGeoJSON()); } catch(e){} 
      } 
    });
    saveSession();
  });
  map.on(L.Draw.Event.DELETED,()=>{ clearAllLabels(); saveSession(); });


  // -----------------------------------------------------------------------
  // L√ìGICA DE DETERMINACI√ìN DE ZONA UTM
  // -----------------------------------------------------------------------

  /**
   * Determina la zona UTM (EPSG) para Per√∫ Sur (17S, 18S, 19S) basada en la longitud.
   * @param {number} lon - Longitud (WGS84).
   * @returns {string} C√≥digo EPSG ('32717', '32718', '32719').
   */
  function getUtmZone(lon) {
    // Rangos aproximados de Per√∫ para las zonas UTM Sur
    if (lon >= -84 && lon < -80) return '32717'; // Zona 17S
    if (lon >= -80 && lon < -72) return '32718'; // Zona 18S (la m√°s com√∫n)
    if (lon >= -72 && lon < -68) return '32719'; // Zona 19S
    return '32718'; // Fallback
  }

  // -----------------------------------------------------------------------
  // FUNCI√ìN PARA C√ÅLCULO DE √ÅREA PLANAR (UTM)
  // -----------------------------------------------------------------------
  /**
   * Calcula el √°rea planar de un pol√≠gono en metros cuadrados (m¬≤) 
   * proyectando a la zona UTM (EPSG:327xx) adecuada.
   * @param {object} geojson - Objeto GeoJSON de un pol√≠gono (en WGS84 Lon/Lat).
   * @param {string | null} [target_crs_code] - C√≥digo EPSG (ej. '32718'). 
   * Si es nulo, usa la zona UTM del centroide (para Dibujo/GPS).
   * Si es un '327xx', usa esa zona (para Excel/CSV).
   * @returns {number} √Årea en metros cuadrados.
   */
  function calculatePlanarArea(geojson, target_crs_code = null) {
    // Si no es un pol√≠gono v√°lido, retorna 0
    if (!geojson || !geojson.geometry || geojson.geometry.type !== 'Polygon') {
      return 0;
    }
    
    // 1. Determinar el CRS objetivo para la proyecci√≥n
    let final_crs = target_crs_code;
    
    // Si el CRS objetivo no est√° definido (Dibujo/GPS) o es 4326, se calcula din√°micamente
    if (!final_crs || final_crs === '4326') {
        try {
            const centroid = turf.centroid(geojson).geometry.coordinates; // [lon, lat]
            final_crs = getUtmZone(centroid[0]);
        } catch(e) {
            console.error("No se pudo calcular centroide para CRS din√°mico.", e);
            final_crs = '32718'; // Fallback seguro
        }
    }
    
    // Solo si el CRS es una proyecci√≥n m√©trica UTM (327xx)
    if (final_crs.startsWith('327')) {
      let area = 0;
      // Coordenadas: [lon, lat] (GeoJSON standard)
      const coords = geojson.geometry.coordinates[0]; 
      
      // 2. Proyectar coordenadas de WGS84 (EPSG:4326) al CRS UTM determinado
      try {
        const projectedCoords = coords.map(c => {
          // c[0] = lon, c[1] = lat
          const projectedPoint = proj4('EPSG:4326', 'EPSG:' + final_crs, [c[0], c[1]]); 
          return { x: projectedPoint[0], y: projectedPoint[1] }; // {x, y} en metros
        });

        // 3. F√≥rmula del cord√≥n de zapato (Shoelace formula) para √°rea planar
        for (let i = 0, j = projectedCoords.length - 1; i < projectedCoords.length; j = i++) {
          const p1 = projectedCoords[i];
          const p2 = projectedCoords[j];
          area += (p2.x + p1.x) * (p2.y - p1.y);
        }
        return Math.abs(area / 2); // √Årea en metros cuadrados
      } catch(e) {
          console.error(`Error al proyectar a EPSG:${final_crs}. Usando Turf Geod√©sico.`, e);
          // Fallback a √°rea geod√©sica si falla la proyecci√≥n
          return turf.area(geojson);
      }
    } 

    // Si no es un CRS UTM esperado, se usa el c√°lculo geod√©sico de Turf (menos preciso)
    return turf.area(geojson);
  }


  // ---------- Label area (MODIFICADA para usar c√°lculo planar y 3 decimales) ----------
  function addOrUpdateLabel(layer){
    try {
      const gj = layer.toGeoJSON();
      // USO de calculatePlanarArea con CRS din√°mico (null) para pol√≠gonos dibujados/GPS
      const area_m2 = calculatePlanarArea(gj, null); 
      // *** MODIFICACI√ìN DE PRECISI√ìN A 3 DECIMALES ***
      const area_ha = parseFloat((area_m2/10000).toFixed(3)); 
      const center = turf.centerOfMass(gj).geometry.coordinates; // [lon,lat]
      if(layer._label) map.removeLayer(layer._label);
      layer._label = L.marker([center[1], center[0]], { icon: L.divIcon({ className:'label', html:`${area_ha.toFixed(3)} ha`}) }).addTo(map);
    } catch(e){}
  }

  function clearAllLabels(){
    // remove area labels and titular labels
    map.eachLayer(l => { if(l instanceof L.Marker && l.options.icon?.options?.className === 'label') map.removeLayer(l); });
    drawnItems.eachLayer(l => { if(l._label){ map.removeLayer(l._label); delete l._label; }});
    labelLayer.clearLayers();
  }

  // ---------- GPS (mantido) ----------
  document.getElementById('btn-gps').onclick=()=>{
    if(watchId){ navigator.geolocation.clearWatch(watchId); watchId=null; document.getElementById('btn-gps').innerHTML='<i class="fa-solid fa-location-dot"></i>&nbsp;Activar GPS'; showStatus('GPS detenido','#d9534f'); return; }
    if(!navigator.geolocation) return alert('GPS no disponible.');
    document.getElementById('btn-gps').innerHTML='<i class="fa-solid fa-stop"></i>&nbsp;Detener GPS';
    showStatus('GPS activado');
    watchId = navigator.geolocation.watchPosition(p=>{
      const lat=p.coords.latitude, lng=p.coords.longitude, acc=p.coords.accuracy;
      if(!gpsMarker) gpsMarker = L.circleMarker([lat,lng],{radius:8,color:'#ff5722',fillColor:'#ff5722',fillOpacity:1}).addTo(map);
      gpsMarker.setLatLng([lat,lng]); gpsMarker.accuracy=acc;
      if(accuracyCircle) map.removeLayer(accuracyCircle);
      accuracyCircle = L.circle([lat,lng],{radius:acc,color:colorForPrecision(acc),weight:1,fillOpacity:0.08}).addTo(map);
      if(acc<=5) gpsMarker.setStyle({color:'#2ecc71',fillColor:'#2ecc71'}); else if(acc<=7) gpsMarker.setStyle({color:'#f1c40f',fillColor:'#f1c40f'}); else gpsMarker.setStyle({color:'#e74c3c',fillColor:'#e74c3c'});
      const current=[lat,lng];
      if(!lastTrackPoint || distanceMeters(lastTrackPoint,current)>10){ trackCoords.push(current); trackLayer.setLatLngs(trackCoords); lastTrackPoint=current; }
      infoPrecision.innerText=`üì° Precisi√≥n: ${acc.toFixed(1)} m`;
      saveSession();
    }, err=>alert("Error GPS: "+err.message), { enableHighAccuracy:true });
  };
  function colorForPrecision(acc){ if(acc<=5) return '#2ecc71'; if(acc<=7) return '#f1c40f'; return '#e74c3c'; }
  function distanceMeters(a,b){ const R=6371000,rad=Math.PI/180; const dLat=(b[0]-a[0])*rad,dLon=(b[1]-a[1])*rad; const lat1=a[0]*rad,lat2=b[0]*rad; const hav=Math.sin(dLat/2)**2+Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(hav)); }

  // ---------- Upload controls (mantido) ----------
  document.getElementById('btn-upload').onclick = ()=> document.getElementById('file-input').click();
  document.getElementById('file-input').onchange = e => {
    const file = e.target.files[0]; if(!file) return;
    const ext = file.name.split('.').pop().toLowerCase();
    const crs = document.getElementById('crs-select').value;
    if(/propiet/i.test(file.name)){
      loadPropietariosFromFile(file);
      return;
    }
    if(ext === 'csv') parseCSV(file, crs); else parseXLSX(file, crs);
  };
  function parseCSV(file, crs){
    Papa.parse(file, { header:true, skipEmptyLines:true, complete: r => {
      const rows = r.data;
      const arr = [];
      rows.forEach(row => {
        const lower = {}; Object.keys(row).forEach(k => lower[k.trim().toLowerCase()] = row[k]);
        const x = parseFloat(lower['este'] ?? lower['x'] ?? lower['lon'] ?? lower['longitud'] ?? lower['longitude'] ?? lower['e'] ?? Object.values(row)[0]);
        const y = parseFloat(lower['norte'] ?? lower['y'] ?? lower['lat'] ?? lower['latitud'] ?? lower['latitude'] ?? lower['n'] ?? Object.values(row)[1]);
        if(!isNaN(x) && !isNaN(y)) arr.push([x,y]);
      });
      handleRows(arr, crs, true);
    }});
  }
  function parseXLSX(file, crs){
    const reader = new FileReader();
    reader.onload = e => {
      const wb = XLSX.read(e.target.result, { type:'binary' });
      const ws = wb.Sheets[wb.SheetNames[0]];
      const data = XLSX.utils.sheet_to_json(ws, { header:1, defval: "" });
      if(!data || data.length < 2) return showStatus('Archivo vac√≠o o sin datos','#d9534f');
      const headers = data[0].map(h => String(h).toLowerCase());
      const colE = headers.findIndex(h => h.includes('este') || h==='x' || h==='e' || h.includes('lon') || h.includes('long'));
      const colN = headers.findIndex(h => h.includes('norte') || h==='y' || h==='n' || h.includes('lat'));
      const coords = data.slice(1).map(r => {
        const vx = (colE >= 0) ? r[colE] : r[0];
        const vy = (colN >= 0) ? r[colN] : r[1];
        return [parseFloat(vx), parseFloat(vy)];
      }).filter(p => !isNaN(p[0]) && !isNaN(p[1]));
      handleRows(coords, crs, true);
    };
    reader.readAsBinaryString(file);
  }

  // ---------- Build polygon robustly and display (MODIFICADA para c√°lculo planar y 3 decimales) ----------
  function handleRows(rows, crs, isArray=false){
    uploadedLayer.clearLayers(); intersectLayer.clearLayers(); labelLayer.clearLayers(); intersectFeatures = []; inputPolygonFeature = null; document.getElementById('tabla-inter').innerHTML = "Procesando...";
    const pointsLatLon = [];
    rows.forEach(r => {
      if(!r) return;
      let x = r[0], y = r[1];
      if(isNaN(x) || isNaN(y)) return;
      let lonLat;
      // Proyecci√≥n: de CRS de entrada a WGS84 (4326) para display en Leaflet
      if(crs === '4326') lonLat = [ parseFloat(x), parseFloat(y) ];
      else {
        try { lonLat = proj4('EPSG:' + crs, 'EPSG:4326', [x, y]); } catch { lonLat = [x,y]; }
      }
      let lon = Number(lonLat[0]); let lat = Number(lonLat[1]);
      if(isNaN(lat) || isNaN(lon)) return;
      const dispLat = lat, dispLon = lon;
      pointsLatLon.push([dispLat, dispLon]);
      L.circleMarker([dispLat, dispLon], { radius:5, color:'#007bff', fillColor:'#007bff', fillOpacity:0.9 }).addTo(uploadedLayer);
    });

    if(pointsLatLon.length < 3){
      document.getElementById('tabla-inter').innerHTML = "<div class='small'>Se requieren al menos 3 coordenadas v√°lidas.</div>";
      showStatus('Se requieren al menos 3 coordenadas v√°lidas','#d9534f');
      return;
    }

    const first = pointsLatLon[0], last = pointsLatLon[pointsLatLon.length - 1];
    if(first[0] !== last[0] || first[1] !== last[1]) pointsLatLon.push(first);

    const poly = L.polygon(pointsLatLon, { color:'#0056b3', fillOpacity:0.15 }).addTo(uploadedLayer);
    
    // Crear GeoJSON en Lon/Lat para c√°lculo y intersecci√≥n
    const coordsLonLat = pointsLatLon.map(p => [p[1], p[0]]);
    if(coordsLonLat.length < 4) return;
    if(coordsLonLat[0][0] !== coordsLonLat[coordsLonLat.length-1][0] || coordsLonLat[0][1] !== coordsLonLat[coordsLonLat.length-1][1]) coordsLonLat.push(coordsLonLat[0]);

    const gj = {
      type: 'Feature',
      properties: { input_crs: crs }, // Guardar el CRS de entrada
      geometry: { type: 'Polygon', coordinates: [ coordsLonLat ] }
    };

    // MODIFICACI√ìN CLAVE: Usar calculatePlanarArea con el CRS seleccionado (crs) y 3 decimales
    try { 
        const area_m2 = calculatePlanarArea(gj, crs);
        gj.properties.area_ha = parseFloat((area_m2 / 10000).toFixed(3)); 
    } catch(e){ 
        console.error("Error al calcular √°rea planar de entrada:", e);
        // Fallback a √°rea geod√©sica si falla el planar
        gj.properties.area_ha = parseFloat((turf.area(gj) / 10000).toFixed(3));
    }
    
    // Actualizar etiqueta del pol√≠gono con el √°rea planar calculada (3 decimales)
    if(poly._label) map.removeLayer(poly._label);
    const center = turf.centerOfMass(gj).geometry.coordinates;
    poly._label = L.marker([center[1], center[0]], { 
        icon: L.divIcon({ className:'label', html:`${gj.properties.area_ha.toFixed(3)} ha`}) 
    }).addTo(map);

    inputPolygonFeature = gj;
    map.fitBounds(poly.getBounds().pad(0.12));
    try { checkIntersection(inputPolygonFeature); } catch(e){ console.error(e); showStatus('Error al consultar MIDAGRI','#d9534f'); }
    saveSession();
  }

  // ---------- MIDAGRI FeatureLayer ----------
  const MIDAGRI_LAYER_URL = 'https://georural.midagri.gob.pe/geoservicios/rest/services/public/Catastro_Rural/MapServer/0';
  const midagriLayer = L.esri.featureLayer({ url: MIDAGRI_LAYER_URL });

  // ---------- Intersection: paint and store features + etiquetas (MODIFICADA para c√°lculo planar y 3 decimales) ----------
  function checkIntersection(geojsonFeature){
    try {
      if(!geojsonFeature) return;
      intersectLayer.clearLayers(); labelLayer.clearLayers(); intersectFeatures = []; document.getElementById('tabla-inter').innerHTML = "Consultando MIDAGRI...";

      midagriLayer.query().intersects(geojsonFeature).run(function(error, featureCollection){
        if(error){
          console.error("MIDAGRI query error:", error);
          showStatus("Error al consultar Catastro Rural (MIDAGRI)", "#d9534f");
          document.getElementById('tabla-inter').innerHTML = "<div class='small'>Error al consultar MIDAGRI. Ver consola.</div>";
          return;
        }

        const features = (featureCollection && featureCollection.features) ? featureCollection.features : [];
        if(features.length === 0){
          showStatus("‚ùå No intersecta con predios del Catastro Rural.", "#d9534f");
          document.getElementById('tabla-inter').innerHTML = "<div class='small'>No hay predios intersectados.</div>";
          return;
        }

        intersectFeatures = features;

        features.forEach(f => {
          const layer = L.geoJSON(f, { style: { color:"#00a94f", weight:2, fillOpacity:0.25 } }).addTo(intersectLayer);
          const props = f.properties || {};
          const id = props.OBJECTID || props.ID || props.OBJECTID_1 || props.oid || "-";
          
          // MODIFICACI√ìN: Usar c√°lculo planar (CRS din√°mico - null) como fallback si el √°rea de la feature no existe o es 0
          let area_ha_calc;
          if (props.AREA && Number(props.AREA) > 0) {
              // √Årea de la fuente (ArcGIS) con 3 decimales
              area_ha_calc = (Number(props.AREA) / 10000).toFixed(3); 
          } else {
              // Calcular planar si AREA no existe o es 0 (3 decimales)
              area_ha_calc = (calculatePlanarArea(f, null) / 10000).toFixed(3); 
          }

          // Build popup with available fields
          let popup = `<div style="font-size:13px"><b>Predio Rural</b><br><b>ID:</b> ${id}<br><b>√Årea (ha):</b> ${area_ha_calc}<br>`;
          const extras = ['DEPARTAMEN','DEPARTAMENTO','PROVINCIA','DISTRITO','NOMBRE','CODIGO','TITULAR','PROPIETARI','cod_predio','COD_PREDIO','CODPREDIO','CODIGO_PRED','COD_PREDIO'];
          extras.forEach(k => { if(props[k]) popup += `<b>${k}:</b> ${props[k]}<br>`; });
          popup += `</div>`;
          layer.bindPopup(popup);

          // Attempt to find titular from propietariosMap using cod_predio property variants
          const candidateKeys = collectCandidateKeysFromFeature(props);
          const titular = findTitularForFeature(candidateKeys);
          if(titular){
            // label at centroid
            const cent = turf.centroid(f).geometry.coordinates;
            L.marker([cent[1], cent[0]], {
              icon: L.divIcon({
                className: 'etiqueta-predio',
                html: titular,
                iconSize: null
              })
            }).addTo(labelLayer);
            // append to popup
            layer.bindPopup(popup + `<b>Titular (CSV):</b> ${titular}<br></div>`);
          }
        });

        renderTable(features);
        showStatus(`‚úÖ Intersecta con ${features.length} predio(s).`, "#0b6b2b");
      });
    } catch(e){
      console.error(e);
      showStatus("Error en verificaci√≥n MIDAGRI","#d9534f");
    }
  }
  
  // ---------- Helper functions for Intersection (mantidas) ----------
  function collectCandidateKeysFromFeature(props){
    const keys = [];
    const possible = ['cod_predio','COD_PREDIO','CODPREDIO','CODIGO_PRED','COD_PREDIO','CODIGO','codigo_predio','num_predio','NUM_PREDIO','NUM'];
    possible.forEach(k => { if(props[k]) keys.push(String(props[k])); });
    Object.keys(props||{}).forEach(k=>{
      const v = props[k];
      if(v && typeof v === 'string' && v.indexOf('_')>=0) keys.push(v);
    });
    const normalized = keys.map(k => String(k).trim().replace(/^"+|"+$/g, '').replace(/^'+|'+$/g, ''));
    const unique = Array.from(new Set(normalized));
    return unique;
  }
  function findTitularForFeature(candidateKeys){
    for(const raw of candidateKeys){
      if(!raw) continue;
      const k = raw.trim();
      if(propietariosMap[k]) return propietariosMap[k];
      const v1 = k.replace(/-/g, '_');
      if(propietariosMap[v1]) return propietariosMap[v1];
      const v2 = k.replace(/\s+/g,'');
      if(propietariosMap[v2]) return propietariosMap[v2];
      const digitsOnly = k.replace(/['"\s]/g,'');
      if(propietariosMap[digitsOnly]) return propietariosMap[digitsOnly];
      const parts = k.split(/[._-]/).filter(Boolean);
      if(parts.length>1){
        const last = parts.slice(-1)[0];
        if(propietariosMap[last]) return propietariosMap[last];
      }
    }
    return null;
  }
  
  // ---------- Render table (MODIFICADA para mostrar √°rea planar y 3 decimales) ----------
  function renderTable(features){
    const div = document.getElementById('tabla-inter');
    if(!features || features.length === 0){ div.innerHTML = "<div class='small'>No hay predios intersectados.</div>"; return; }
    
    const allKeys = new Set();
    features.forEach(f => { Object.keys(f.properties || {}).forEach(k => allKeys.add(k)); });
    
    // Add columns for calculated area and titular
    const keys = Array.from(allKeys);
    if(!keys.includes('AREA_HA_ORIGEN')) keys.push('AREA_HA_ORIGEN');
    if(!keys.includes('AREA_HA_PLANAR')) keys.push('AREA_HA_PLANAR'); // New calculated planar area column
    if(!keys.includes('TITULAR_CSV')) keys.push('TITULAR_CSV');

    let html = "<table><thead><tr>";
    keys.forEach(k => html += `<th>${k.replace('AREA_HA_PLANAR', '√ÅREA PLANAR (HA)').replace('AREA_HA_ORIGEN', '√ÅREA ORIGEN (HA)').replace('TITULAR_CSV', 'TITULAR (CSV)')}</th>`);
    html += "</tr></thead><tbody>";
    
    features.forEach(f => {
      const props = f.properties || {};
      const titular = findTitularForFeature(collectCandidateKeysFromFeature(props)) || '';
      
      // Recalcular √°rea planar para la tabla (3 decimales)
      const area_planar_calc = (calculatePlanarArea(f, null) / 10000).toFixed(3); 
      
      html += "<tr>";
      keys.forEach(k => {
          let value = '';
          if (k === 'TITULAR_CSV') {
              value = titular;
          } else if (k === 'AREA_HA_PLANAR') {
              value = area_planar_calc;
          } else if (k === 'AREA_HA_ORIGEN') {
              // Area from service properties, if available (3 decimales)
              value = props.AREA ? (Number(props.AREA) / 10000).toFixed(3) : 'N/A';
          } else {
              value = (props && props[k]) ? String(props[k]) : '';
          }
          html += `<td>${value}</td>`;
      });
      html += "</tr>";
    });
    html += "</tbody></table>";
    div.innerHTML = html;
  }
  
  // ---------- Downloads (MODIFICADA para incluir √°rea planar con 3 decimales) ----------
  document.getElementById('btn-download-midagri-geo').onclick = () => {
    if(!intersectFeatures || intersectFeatures.length === 0){ showStatus('No hay predios para descargar','#d9534f'); return; }
    const fc = { type:'FeatureCollection', features: intersectFeatures.map(f => {
        const new_f = JSON.parse(JSON.stringify(f));
        // Asegurar que el √°rea calculada planar est√© en las propiedades
        new_f.properties = new_f.properties || {};
        const planar_m2 = calculatePlanarArea(f, null).toFixed(2);
        // *** PRECISI√ìN A 3 DECIMALES ***
        new_f.properties.AREA_PLANAR_HA = (Number(planar_m2) / 10000).toFixed(3);
        new_f.properties.AREA_PLANAR_M2 = planar_m2; // Mantenemos M2 a 2 decimales, HA a 3.
        return new_f;
    })};
    const blob = new Blob([JSON.stringify(fc)], { type:'application/geo+json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'predios_intersectados.geojson'; a.click(); URL.revokeObjectURL(url);
    showStatus('‚úÖ GeoJSON descargado');
  };

  document.getElementById('btn-download-midagri-csv').onclick = () => {
    if(!intersectFeatures || intersectFeatures.length === 0){ showStatus('No hay predios para descargar','#d9534f'); return; }
    const rows = intersectFeatures.map(f => {
      const p = f.properties || {};
      const titular = findTitularForFeature(collectCandidateKeysFromFeature(p)) || p.TITULAR || p.NOMBRE || '';
      
      // MODIFICACI√ìN: Usar c√°lculo planar (CRS din√°mico) con 3 decimales
      const area_planar_calc = (calculatePlanarArea(f, null) / 10000).toFixed(3); 
      
      return {
        ID: p.OBJECTID || p.ID || p.OBJECTID_1 || "",
        COD_PREDIO: p.cod_predio || p.COD_PREDIO || '',
        // *** PRECISI√ìN A 3 DECIMALES ***
        AREA_HA_ORIGEN: p.AREA ? (Number(p.AREA)/10000).toFixed(3) : 'N/A',
        AREA_HA_PLANAR: area_planar_calc, // √Årea calculada con precisi√≥n UTM (3 decimales)
        DEPARTAMENTO: p.DEPARTAMEN || p.DEPARTAMENTO || "",
        PROVINCIA: p.PROVINCIA || "",
        DISTRITO: p.DISTRITO || "",
        TITULAR: titular
      };
    });
    const csv = Papa.unparse(rows);
    const blob = new Blob([csv], { type:'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'predios_intersectados.csv'; a.click(); URL.revokeObjectURL(url);
    showStatus('‚úÖ CSV descargado');
  };

  // ---------- Download input polygon (MODIFICADA para asegurar el √°rea planar con 3 decimales) ----------
  document.getElementById('btn-download-input-geo').onclick = () => {
    if(!inputPolygonFeature){ showStatus('No hay pol√≠gono de entrada','#d9534f'); return; }
    const gj = JSON.parse(JSON.stringify(inputPolygonFeature));
    gj.properties = gj.properties || {};
    // El √°rea ya fue calculada de forma planar en handleRows o gps-vertex
    if (!gj.properties.area_ha) {
        // Fallback: calcular planar con el CRS guardado o din√°mico (null) (3 decimales)
        const crs = gj.properties.input_crs || null; 
        gj.properties.area_ha = parseFloat((calculatePlanarArea(gj, crs)/10000).toFixed(3));
    } else {
         // Asegurar 3 decimales en la propiedad (en caso de que se haya guardado con menos)
         gj.properties.area_ha = parseFloat(gj.properties.area_ha).toFixed(3);
    }
    const blob = new Blob([JSON.stringify(gj)], { type:'application/geo+json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'poligono_entrada.geojson'; a.click(); URL.revokeObjectURL(url);
    showStatus('‚úÖ Pol√≠gono descargado');
  };

  // ---------- Zoom to intersect (mantido) ----------
  document.getElementById('btn-zoom-intersect').onclick = () => {
    if(!intersectLayer || intersectLayer.getLayers().length === 0){ showStatus('No hay predios para hacer zoom','#d9534f'); return; }
    map.fitBounds(intersectLayer.getBounds().pad(0.15));
  };
  
  // ---------- AGREGAR V√âRTICE GPS (MODIFICADA para usar c√°lculo planar y 3 decimales) ----------
  document.getElementById('btn-gps-vertex').onclick = () => {
    if(!gpsMarker) return alert('Activa el GPS primero.');
    const acc = gpsMarker.accuracy || 999;
    if(acc>7 && !confirm(`Precisi√≥n baja (${acc.toFixed(1)} m). ¬øAgregar v√©rtice igualmente?`)) return;
    const p = gpsMarker.getLatLng();
    gpsVertices.push([p.lat,p.lng]);
    L.circleMarker(p,{radius:5,color:'#0b6b2b',fillColor:'#0b6b2b',fillOpacity:1}).addTo(gpsLayer);
    
    if(gpsVertices.length>=3){
      if(!activePolygon) activePolygon = L.polygon(gpsVertices, { color:'#0b6b2b', fillOpacity:0.12 }).addTo(gpsLayer);
      else activePolygon.setLatLngs(gpsVertices);
      
      // La funci√≥n addOrUpdateLabel internamente usa calculatePlanarArea(gj, null) (CRS din√°mico) con 3 decimales
      addOrUpdateLabel(activePolygon);
      
      const coordsLonLat = gpsVertices.map(pp => [pp[1], pp[0]]);
      if(coordsLonLat[0][0] !== coordsLonLat[coordsLonLat.length-1][0] || coordsLonLat[0][1] !== coordsLonLat[coordsLonLat.length-1][1]) coordsLonLat.push(coordsLonLat[0]);
      
      inputPolygonFeature = { type:'Feature', properties:{}, geometry:{ type:'Polygon', coordinates:[coordsLonLat] } };
      // MODIFICACI√ìN: Usar c√°lculo planar (CRS din√°mico - null) con 3 decimales
      inputPolygonFeature.properties.area_ha = parseFloat((calculatePlanarArea(inputPolygonFeature, null)/10000).toFixed(3));
      
      try { checkIntersection(inputPolygonFeature); } catch(e){}
    }
    
    saveSession();
  };

  // ---------- Cargar CSV de propietarios (mantido) ----------
  function loadPropietariosCSVFromRepo(){
    const repoPath = 'data/propietarios.csv';
    fetch(repoPath).then(resp=>{
      if(!resp.ok) throw new Error('HTTP '+resp.status);
      return resp.text();
    }).then(txt=>{
      Papa.parse(txt, { header:true, skipEmptyLines:true, delimiter: detectDelimiter(txt), complete: r=>{
        const rows = r.data || [];
        propietariosMap = {};
        rows.forEach(row=>{
          const lc = {};
          Object.keys(row).forEach(k => lc[k.trim().toLowerCase()] = row[k]);
          const nombre = lc['nombre'] ?? lc['name'] ?? lc['titular'] ?? row[Object.keys(row)[1]] ?? '';
          const cod = lc['cod_predio'] ?? lc['codpredio'] ?? lc['codigo_predio'] ?? lc['cod'] ?? row[Object.keys(row)[0]];
          if(!cod) return;
          const raw = String(cod).trim().replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
          const nm = String(nombre || '').trim();
          if(raw) propietariosMap[raw] = nm;
        });
        console.log('Propietarios cargados', propietariosMap);
        showStatus('‚úÖ Propietarios cargados desde data/propietarios.csv',  '#0b6b2b', 2500);
      }});
    }).catch(err=>{
      console.warn('No se pudo cargar data/propietarios.csv autom√°ticamente:', err);
      showStatus('No se encontr√≥ data/propietarios.csv ‚Äî puedes subirlo manualmente', '#d9534f', 3500);
      setupPropietariosUploadFallback();
    });
  }
  function detectDelimiter(txt){
    const firstLine = txt.split(/\r?\n/)[0];
    if((firstLine.match(/;/g)||[]).length > (firstLine.match(/,/g)||[]).length) return ';';
    return ',';
  }
  function setupPropietariosUploadFallback(){
    document.getElementById('file-input').addEventListener('change', function(e){
      const file = e.target.files[0];
      if(!file) return;
      if(/propiet/i.test(file.name)){
        loadPropietariosFromFile(file);
      }
    });
  }
  function loadPropietariosFromFile(file){
    Papa.parse(file, { header:true, skipEmptyLines:true, delimiter: detectDelimiterFromFileName(file.name), complete: r=>{
      propietariosMap = {};
      (r.data||[]).forEach(row=>{
        const lc = {};
        Object.keys(row).forEach(k => lc[k.trim().toLowerCase()] = row[k]);
        const nombre = lc['nombre'] ?? lc['name'] ?? row[Object.keys(row)[1]] ?? '';
        const cod = lc['cod_predio'] ?? lc['codpredio'] ?? lc['cod'] ?? row[Object.keys(row)[0]];
        if(!cod) return;
        const raw = String(cod).trim().replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
        propietariosMap[raw] = String(nombre||'').trim();
      });
      showStatus('‚úÖ Propietarios cargados (manual)', '#0b6b2b', 2500);
    }});
  }
  function detectDelimiterFromFileName(name){ return name.indexOf('.csv')>=0 ? ';' : ','; }

  // ---------- Save / restore session (mantido) ----------
  function saveSession(){
    const data = { drawn: drawnItems.toGeoJSON(), gps: gpsLayer.toGeoJSON(), uploaded: uploadedLayer.toGeoJSON(), track: trackCoords };
    localStorage.setItem("bps_sesion", JSON.stringify(data));
  }
  window.addEventListener("load", ()=>{
    const saved = localStorage.getItem("bps_sesion");
    if(saved && confirm("üîÑ ¬øDeseas restaurar tu √∫ltima sesi√≥n?")){
      const data = JSON.parse(saved);
      L.geoJSON(data.drawn, { onEachFeature:(f,l)=>{ drawnItems.addLayer(l); if(l instanceof L.Polygon) addOrUpdateLabel(l); }});
      L.geoJSON(data.gps, { onEachFeature:(f,l)=>{ gpsLayer.addLayer(l); }});
      L.geoJSON(data.uploaded, { onEachFeature:(f,l)=>{ uploadedLayer.addLayer(l); }});
      trackCoords = data.track || [];
      trackLayer.setLatLngs(trackCoords);
    }
    loadPropietariosCSVFromRepo();
  });

  // ---------- Clear (mantido) ----------
  document.getElementById('btn-clear').onclick = () => {
    if(!confirm('¬øEliminar todo?')) return;
    gpsLayer.clearLayers(); drawnItems.clearLayers(); uploadedLayer.clearLayers(); trackLayer.setLatLngs([]); intersectLayer.clearLayers(); labelLayer.clearLayers();
    gpsVertices=[]; trackCoords=[]; activePolygon=null; lastTrackPoint=null; intersectFeatures=null; inputPolygonFeature=null;
    if(gpsMarker){ map.removeLayer(gpsMarker); gpsMarker=null; } if(accuracyCircle){ map.removeLayer(accuracyCircle); accuracyCircle=null; }
    clearAllLabels(); infoPrecision.innerText='üì° Precisi√≥n: -- m'; localStorage.removeItem("bps_sesion");
    if(watchId){ navigator.geolocation.clearWatch(watchId); watchId=null; document.getElementById('btn-gps').innerHTML='<i class="fa-solid fa-location-dot"></i>&nbsp;Activar GPS'; }
    showStatus('üßπ Todo eliminado','#d9534f');
  };

  // ---------- End ----------
  </script>
</body>
</html>
